<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Define a fuzz target."><title>fuzz_target in libfuzzer_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="libfuzzer_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../libfuzzer_sys/index.html">libfuzzer_<wbr>sys</a><span class="version">0.4.8</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="index.html">libfuzzer_sys</a>::<wbr><a class="macro" href="#">fuzz_target</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/libfuzzer_sys/lib.rs.html#200-304">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><span class="macro">macro_rules!</span> fuzz_target {
    (|<span class="macro-nonterminal">$bytes</span>:ident| <span class="macro-nonterminal">$body</span>:expr) =&gt; { ... };
    (|<span class="macro-nonterminal">$data</span>:ident: <span class="kw-2">&amp;</span>[u8]| <span class="macro-nonterminal">$body</span>:expr) =&gt; { ... };
    (|<span class="macro-nonterminal">$data</span>:ident: <span class="macro-nonterminal">$dty</span>:ty| <span class="macro-nonterminal">$body</span>:expr) =&gt; { ... };
    (|<span class="macro-nonterminal">$data</span>:ident: <span class="macro-nonterminal">$dty</span>:ty| -&gt; <span class="macro-nonterminal">$rty</span>:ty <span class="macro-nonterminal">$body</span>:block) =&gt; { ... };
}</pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Define a fuzz target.</p>
<h3 id="example"><a class="doc-anchor" href="#example">§</a>Example</h3>
<p>This example takes a <code>&amp;[u8]</code> slice and attempts to parse it. The parsing
might fail and return an <code>Err</code>, but it shouldn’t ever panic or segfault.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![no_main]

</span><span class="kw">use </span>libfuzzer_sys::fuzz_target;

<span class="comment">// Note: `|input|` is short for `|input: &amp;[u8]|`.
</span><span class="macro">fuzz_target!</span>(|input| {
    <span class="kw">let </span>_result: <span class="prelude-ty">Result</span>&lt;<span class="kw">_</span>, <span class="kw">_</span>&gt; = my_crate::parse(input);
});</code></pre></div>
<h3 id="rejecting-inputs"><a class="doc-anchor" href="#rejecting-inputs">§</a>Rejecting Inputs</h3>
<p>It may be desirable to reject some inputs, i.e. to not add them to the
corpus.</p>
<p>For example, when fuzzing an API consisting of parsing and other logic,
one may want to allow only those inputs into the corpus that parse
successfully. To indicate whether an input should be kept in or rejected
from the corpus, return either <a href="enum.Corpus.html#variant.Keep" title="variant libfuzzer_sys::Corpus::Keep">Corpus::Keep</a> or <a href="enum.Corpus.html#variant.Reject" title="variant libfuzzer_sys::Corpus::Reject">Corpus::Reject</a> from your
fuzz target. The default behavior (e.g. if <code>()</code> is returned) is to keep the
input in the corpus.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![no_main]

</span><span class="kw">use </span>libfuzzer_sys::{Corpus, fuzz_target};

<span class="macro">fuzz_target!</span>(|input: String| -&gt; Corpus {
    <span class="kw">let </span>parts: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = input.splitn(<span class="number">2</span>, <span class="string">'='</span>).collect();
    <span class="kw">if </span>parts.len() != <span class="number">2 </span>{
        <span class="kw">return </span>Corpus::Reject;
    }

    <span class="kw">let </span>key = parts[<span class="number">0</span>];
    <span class="kw">let </span>value = parts[<span class="number">1</span>];
    <span class="kw">let </span>_result: <span class="prelude-ty">Result</span>&lt;<span class="kw">_</span>, <span class="kw">_</span>&gt; = my_crate::parse(key, value);
    Corpus::Keep
});</code></pre></div>
<h3 id="arbitrary-input-types"><a class="doc-anchor" href="#arbitrary-input-types">§</a>Arbitrary Input Types</h3>
<p>The input is a <code>&amp;[u8]</code> slice by default, but you can take arbitrary input
types, as long as the type implements <a href="https://docs.rs/arbitrary/*/arbitrary/trait.Arbitrary.html">the <code>arbitrary</code> crate’s <code>Arbitrary</code>
trait</a> (which is
also re-exported as <code>libfuzzer_sys::arbitrary::Arbitrary</code> for convenience).</p>
<p>For example, if you wanted to take an arbitrary RGB color, you could do the
following:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![no_main]

</span><span class="kw">use </span>libfuzzer_sys::{arbitrary::{Arbitrary, Error, Unstructured}, fuzz_target};

<span class="attr">#[derive(Debug)]
</span><span class="kw">pub struct </span>Rgb {
    r: u8,
    g: u8,
    b: u8,
}

<span class="kw">impl</span>&lt;<span class="lifetime">'a</span>&gt; Arbitrary&lt;<span class="lifetime">'a</span>&gt; <span class="kw">for </span>Rgb {
    <span class="kw">fn </span>arbitrary(raw: <span class="kw-2">&amp;mut </span>Unstructured&lt;<span class="lifetime">'a</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, Error&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>buf = [<span class="number">0</span>; <span class="number">3</span>];
        raw.fill_buffer(<span class="kw-2">&amp;mut </span>buf)<span class="question-mark">?</span>;
        <span class="kw">let </span>r = buf[<span class="number">0</span>];
        <span class="kw">let </span>g = buf[<span class="number">1</span>];
        <span class="kw">let </span>b = buf[<span class="number">2</span>];
        <span class="prelude-val">Ok</span>(Rgb { r, g, b })
    }
}

<span class="comment">// Write a fuzz target that works with RGB colors instead of raw bytes.
</span><span class="macro">fuzz_target!</span>(|color: Rgb| {
    my_crate::convert_color(color);
});</code></pre></div>
<p>You can also enable the <code>arbitrary</code> crate’s custom derive via this crate’s
<code>"arbitrary-derive"</code> cargo feature.</p>
</div></details></section></div></main></body></html>