<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Define a custom mutator."><title>fuzz_mutator in libfuzzer_sys - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="libfuzzer_sys" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-118b08c4c78b968e.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../libfuzzer_sys/index.html">libfuzzer_<wbr>sys</a><span class="version">0.4.8</span></h2></div><div class="sidebar-elems"></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Macro <a href="index.html">libfuzzer_sys</a>::<wbr><a class="macro" href="#">fuzz_mutator</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../src/libfuzzer_sys/lib.rs.html#448-495">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><span class="macro">macro_rules!</span> fuzz_mutator {
    (
        |
        <span class="macro-nonterminal">$data</span>:ident : <span class="kw-2">&amp;mut </span>[u8] ,
        <span class="macro-nonterminal">$size</span>:ident : usize ,
        <span class="macro-nonterminal">$max_size</span>:ident : usize ,
        <span class="macro-nonterminal">$seed</span>:ident : u32 $(,)*
        |
        <span class="macro-nonterminal">$body</span>:block
    ) =&gt; { ... };
}</pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Define a custom mutator.</p>
<p>This is optional, and libFuzzer will use its own, default mutation strategy
if this is not provided.</p>
<p>You might consider using a custom mutator when your fuzz target is very
particular about the shape of its input:</p>
<ul>
<li>You want to fuzz “deeper” than just the parser.</li>
<li>The input contains checksums that have to match the hash of some subset of
the data or else the whole thing is invalid, and therefore mutating any of
that subset means you need to recompute the checksums.</li>
<li>Small random changes to the input buffer make it invalid.</li>
</ul>
<p>That is, a custom mutator is useful in similar situations where <a href="macro.fuzz_target.html#arbitrary-input-types">a <code>T: Arbitrary</code> input type</a> is
useful. Note that the two approaches are not mutually exclusive; you can use
whichever is easier for your problem domain or both!</p>
<h3 id="implementation-contract"><a class="doc-anchor" href="#implementation-contract">§</a>Implementation Contract</h3>
<p>The original, unmodified input is given in <code>data[..size]</code>.</p>
<p>You must modify the data in place and return the new size.</p>
<p>The new size should not be greater than <code>max_size</code>. If this is not the case,
then the <code>data</code> will be truncated to fit within <code>max_size</code>. Note that
<code>max_size &lt; size</code> is possible when shrinking test cases.</p>
<p>You must produce the same mutation given the same <code>seed</code>. Generally, when
choosing what kind of mutation to make or where to mutate, you should start
by creating a random number generator (RNG) that is seeded with the given
<code>seed</code> and then consult the RNG whenever making a decision:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![no_main]

</span><span class="kw">use </span>rand::{rngs::StdRng, Rng, SeedableRng};

<span class="macro">libfuzzer_sys::fuzz_mutator!</span>(|data: <span class="kw-2">&amp;mut </span>[u8], size: usize, max_size: usize, seed: u32| {
    <span class="kw">let </span><span class="kw-2">mut </span>rng = StdRng::seed_from_u64(seed <span class="kw">as </span>u64);

    <span class="comment">// Choose which of our four supported kinds of mutations we want to make.
    </span><span class="kw">match </span>rng.gen_range(<span class="number">0</span>..<span class="number">4</span>) {
        <span class="number">0 </span>=&gt; first_mutation(rng, data, size, max_size),
        <span class="number">1 </span>=&gt; second_mutation(rng, data, size, max_size),
        <span class="number">2 </span>=&gt; third_mutation(rng, data, size, max_size),
        <span class="number">3 </span>=&gt; fourth_mutation(rng, data, size, max_size),
        <span class="kw">_ </span>=&gt; <span class="macro">unreachable!</span>()
    }
});</code></pre></div>
<h3 id="example-compression"><a class="doc-anchor" href="#example-compression">§</a>Example: Compression</h3>
<p>Consider a simple fuzz target that takes compressed data as input,
decompresses it, and then asserts that the decompressed data doesn’t begin
with “boom”. It is difficult for <code>libFuzzer</code> (or any other fuzzer) to crash
this fuzz target because nearly all mutations it makes will invalidate the
compression format. Therefore, we use a custom mutator that decompresses the
raw input, mutates the decompressed data, and then recompresses it. This
allows <code>libFuzzer</code> to quickly discover crashing inputs.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![no_main]

</span><span class="kw">use </span>flate2::{read::GzDecoder, write::GzEncoder, Compression};
<span class="kw">use </span>libfuzzer_sys::{fuzz_mutator, fuzz_target};
<span class="kw">use </span>std::io::{Read, Write};

<span class="macro">fuzz_target!</span>(|data: <span class="kw-2">&amp;</span>[u8]| {
    <span class="comment">// Decompress the input data and crash if it starts with "boom".
    </span><span class="kw">if let </span><span class="prelude-val">Some</span>(data) = decompress(data) {
        <span class="kw">if </span>data.starts_with(<span class="string">b"boom"</span>) {
            <span class="macro">panic!</span>();
        }
    }
});

<span class="macro">fuzz_mutator!</span>(
    |data: <span class="kw-2">&amp;mut </span>[u8], size: usize, max_size: usize, _seed: u32| {
        <span class="comment">// Decompress the input data. If that fails, use a dummy value.
        </span><span class="kw">let </span><span class="kw-2">mut </span>decompressed = decompress(<span class="kw-2">&amp;</span>data[..size]).unwrap_or_else(|| <span class="string">b"hi"</span>.to_vec());

        <span class="comment">// Mutate the decompressed data with `libFuzzer`'s default mutator. Make
        // the `decompressed` vec's extra capacity available for insertion
        // mutations via `resize`.
        </span><span class="kw">let </span>len = decompressed.len();
        <span class="kw">let </span>cap = decompressed.capacity();
        decompressed.resize(cap, <span class="number">0</span>);
        <span class="kw">let </span>new_decompressed_size = libfuzzer_sys::fuzzer_mutate(<span class="kw-2">&amp;mut </span>decompressed, len, cap);

        <span class="comment">// Recompress the mutated data.
        </span><span class="kw">let </span>compressed = compress(<span class="kw-2">&amp;</span>decompressed[..new_decompressed_size]);

        <span class="comment">// Copy the recompressed mutated data into `data` and return the new size.
        </span><span class="kw">let </span>new_size = std::cmp::min(max_size, compressed.len());
        data[..new_size].copy_from_slice(<span class="kw-2">&amp;</span>compressed[..new_size]);
        new_size
    }
);

<span class="kw">fn </span>decompress(compressed_data: <span class="kw-2">&amp;</span>[u8]) -&gt; <span class="prelude-ty">Option</span>&lt;Vec&lt;u8&gt;&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>decoder = GzDecoder::new(compressed_data);
    <span class="kw">let </span><span class="kw-2">mut </span>decompressed = Vec::new();
    <span class="kw">if </span>decoder.read_to_end(<span class="kw-2">&amp;mut </span>decompressed).is_ok() {
        <span class="prelude-val">Some</span>(decompressed)
    } <span class="kw">else </span>{
        <span class="prelude-val">None
    </span>}
}

<span class="kw">fn </span>compress(data: <span class="kw-2">&amp;</span>[u8]) -&gt; Vec&lt;u8&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>encoder = GzEncoder::new(Vec::new(), Compression::default());
    encoder
        .write_all(data)
        .expect(<span class="string">"writing into a vec is infallible"</span>);
    encoder.finish().expect(<span class="string">"writing into a vec is infallible"</span>)
}</code></pre></div>
<p>This example is inspired by <a href="https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md#example-compression">a similar example from the official <code>libFuzzer</code>
docs</a>.</p>
<h3 id="more-example-ideas"><a class="doc-anchor" href="#more-example-ideas">§</a>More Example Ideas</h3>
<ul>
<li>
<p>A PNG custom mutator that decodes a PNG, mutates the image, and then
re-encodes the mutated image as a new PNG.</p>
</li>
<li>
<p>A <a href="https://serde.rs/"><code>serde</code></a> custom mutator that deserializes your
structure, mutates it, and then reserializes it.</p>
</li>
<li>
<p>A Wasm binary custom mutator that inserts, replaces, and removes a
bytecode instruction in a function’s body.</p>
</li>
<li>
<p>An HTTP request custom mutator that inserts, replaces, and removes a
header from an HTTP request.</p>
</li>
</ul>
</div></details></section></div></main></body></html>